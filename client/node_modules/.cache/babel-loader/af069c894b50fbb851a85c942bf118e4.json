{"ast":null,"code":"import { Component as e, useRef as t, useEffect as n } from \"react\";\nimport r from \"prop-types\";\n\nfunction o(e) {\n  return (o = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n    return typeof e;\n  } : function (e) {\n    return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n  })(e);\n}\n\nfunction i(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var r = t[n];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n  }\n}\n\nfunction u(e) {\n  return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n    return e.__proto__ || Object.getPrototypeOf(e);\n  })(e);\n}\n\nfunction l(e, t) {\n  return (l = Object.setPrototypeOf || function (e, t) {\n    return e.__proto__ = t, e;\n  })(e, t);\n}\n\nfunction c(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction a(e, t) {\n  return !t || \"object\" != typeof t && \"function\" != typeof t ? c(e) : t;\n}\n\nfunction s(e) {\n  var t = function () {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n\n    try {\n      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n    } catch (e) {\n      return !1;\n    }\n  }();\n\n  return function () {\n    var n,\n        r = u(e);\n\n    if (t) {\n      var o = u(this).constructor;\n      n = Reflect.construct(r, arguments, o);\n    } else n = r.apply(this, arguments);\n\n    return a(this, n);\n  };\n}\n\nvar d = \"object\" === (\"undefined\" == typeof window || \"undefined\" == typeof window ? \"undefined\" : o(window)),\n    f = d ? document : {},\n    v = [\"mousemove\", \"keydown\", \"wheel\", \"DOMMouseScroll\", \"mousewheel\", \"mousedown\", \"touchstart\", \"touchmove\", \"MSPointerDown\", \"MSPointerMove\", \"visibilitychange\"];\n\nfunction p(e, t) {\n  var n;\n  return function () {\n    for (var r = arguments.length, o = new Array(r), i = 0; i < r; i++) o[i] = arguments[i];\n\n    n && clearTimeout(n), n = setTimeout(function () {\n      e.apply(void 0, o), n = null;\n    }, t);\n  };\n}\n\nfunction h(e, t) {\n  var n = 0;\n  return function () {\n    var r = new Date().getTime();\n    if (!(r - n < t)) return n = r, e.apply(void 0, arguments);\n  };\n}\n\nvar m = function (t) {\n  !function (e, t) {\n    if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n    e.prototype = Object.create(t && t.prototype, {\n      constructor: {\n        value: e,\n        writable: !0,\n        configurable: !0\n      }\n    }), t && l(e, t);\n  }(a, e);\n  var n,\n      r,\n      o,\n      u = s(a);\n\n  function a(e) {\n    var t;\n    if (function (e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }(this, a), (t = u.call(this, e)).state = {\n      idle: !1,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      lastIdle: null,\n      idleTime: 0,\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }, t.tId = null, t.eventsBound = !1, e.debounce > 0 && e.throttle > 0) throw new Error(\"onAction can either be throttled or debounced (not both)\");\n    return e.debounce > 0 ? t._onAction = p(e.onAction, e.debounce) : e.throttle > 0 ? t._onAction = h(e.onAction, e.throttle) : e.onAction ? t._onAction = e.onAction : t._onAction = function () {}, e.eventsThrottle > 0 ? t._handleEvent = h(t._handleEvent.bind(c(t)), e.eventsThrottle) : t._handleEvent = t._handleEvent.bind(c(t)), e.startOnMount || (t.state.idle = !0), t._toggleIdleState = t._toggleIdleState.bind(c(t)), t.reset = t.reset.bind(c(t)), t.pause = t.pause.bind(c(t)), t.resume = t.resume.bind(c(t)), t.getRemainingTime = t.getRemainingTime.bind(c(t)), t.getElapsedTime = t.getElapsedTime.bind(c(t)), t.getLastActiveTime = t.getLastActiveTime.bind(c(t)), t.isIdle = t.isIdle.bind(c(t)), t;\n  }\n\n  return n = a, (r = [{\n    key: \"componentDidMount\",\n    value: function () {\n      this._bindEvents(), this.props.startOnMount && this.reset();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function (e) {\n      e.debounce !== this.props.debounce && (this._onAction = p(this._onAction, this.props.debounce)), e.throttle !== this.props.throttle && (this._onAction = h(this._onAction, this.props.throttle)), e.eventsThrottle !== this.props.eventsThrottle && (this._handleEvent = h(this._handleEvent, this.props.eventsThrottle));\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function () {\n      clearTimeout(this.tId), this._unbindEvents(!0);\n    }\n  }, {\n    key: \"render\",\n    value: function () {\n      return this.props.children || null;\n    }\n  }, {\n    key: \"_bindEvents\",\n    value: function () {\n      var e = this;\n\n      if (d) {\n        var t = this.props,\n            n = t.element,\n            r = t.events,\n            o = t.passive,\n            i = t.capture;\n        this.eventsBound || (r.forEach(function (t) {\n          n.addEventListener(t, e._handleEvent, {\n            capture: i,\n            passive: o\n          });\n        }), this.eventsBound = !0);\n      }\n    }\n  }, {\n    key: \"_unbindEvents\",\n    value: function () {\n      var e = this,\n          t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n\n      if (d) {\n        var n = this.props,\n            r = n.element,\n            o = n.events,\n            i = n.passive,\n            u = n.capture;\n        (this.eventsBound || t) && (o.forEach(function (t) {\n          r.removeEventListener(t, e._handleEvent, {\n            capture: u,\n            passive: i\n          });\n        }), this.eventsBound = !1);\n      }\n    }\n  }, {\n    key: \"_toggleIdleState\",\n    value: function (e) {\n      var t = this;\n      this.setState(function (e) {\n        return {\n          idle: !e.idle,\n          lastIdle: e.idle ? e.lastIdle : +new Date() - t.props.timeout,\n          idleTime: e.idle ? e.idleTime + +new Date() - e.lastIdle : e.idleTime\n        };\n      }, function () {\n        var n = t.props,\n            r = n.onActive,\n            o = n.onIdle,\n            i = n.stopOnIdle;\n        t.state.idle ? (i && (clearTimeout(t.tId), t.tId = null, t._unbindEvents()), o(e)) : i || (t._bindEvents(), r(e));\n      });\n    }\n  }, {\n    key: \"_handleEvent\",\n    value: function (e) {\n      var t = this.state,\n          n = t.remaining,\n          r = t.pageX,\n          o = t.pageY,\n          i = t.idle,\n          u = this.props,\n          l = u.timeout,\n          c = u.stopOnIdle;\n\n      if (this._onAction(e), !n) {\n        if (\"mousemove\" === e.type) {\n          if (e.pageX === r && e.pageY === o) return;\n          if (void 0 === e.pageX && void 0 === e.pageY) return;\n          if (this.getElapsedTime() < 200) return;\n        }\n\n        clearTimeout(this.tId), this.tId = null;\n        var a = +new Date() - this.getLastActiveTime();\n        (i && !c || !i && a > l) && this._toggleIdleState(e), this.setState({\n          lastActive: +new Date(),\n          pageX: e.pageX,\n          pageY: e.pageY\n        }), i && c || (this.tId = setTimeout(this._toggleIdleState, l));\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function () {\n      clearTimeout(this.tId), this.tId = null, this._bindEvents(), this.setState({\n        idle: !1,\n        oldDate: +new Date(),\n        lastActive: +new Date(),\n        remaining: null\n      });\n      var e = this.props.timeout;\n      this.tId = setTimeout(this._toggleIdleState, e);\n    }\n  }, {\n    key: \"pause\",\n    value: function () {\n      null === this.state.remaining && (this._unbindEvents(), clearTimeout(this.tId), this.tId = null, this.setState({\n        remaining: this.getRemainingTime()\n      }));\n    }\n  }, {\n    key: \"resume\",\n    value: function () {\n      var e = this.state,\n          t = e.remaining,\n          n = e.idle;\n      null !== t && (this._bindEvents(), n || (this.tId = setTimeout(this._toggleIdleState, t), this.setState({\n        remaining: null,\n        lastActive: +new Date()\n      })));\n    }\n  }, {\n    key: \"getRemainingTime\",\n    value: function () {\n      var e = this.state,\n          t = e.remaining,\n          n = e.lastActive,\n          r = this.props.timeout;\n      if (null !== t) return t < 0 ? 0 : t;\n      var o = r - (+new Date() - n);\n      return o < 0 ? 0 : o;\n    }\n  }, {\n    key: \"getElapsedTime\",\n    value: function () {\n      var e = this.state.oldDate;\n      return +new Date() - e;\n    }\n  }, {\n    key: \"getLastIdleTime\",\n    value: function () {\n      return this.state.lastIdle;\n    }\n  }, {\n    key: \"getTotalIdleTime\",\n    value: function () {\n      var e = this.state,\n          t = e.idle,\n          n = e.lastIdle,\n          r = e.idleTime;\n      return t ? +new Date() - n + r : r;\n    }\n  }, {\n    key: \"getLastActiveTime\",\n    value: function () {\n      return this.state.lastActive;\n    }\n  }, {\n    key: \"getTotalActiveTime\",\n    value: function () {\n      return this.getElapsedTime() - this.getTotalIdleTime();\n    }\n  }, {\n    key: \"isIdle\",\n    value: function () {\n      return this.state.idle;\n    }\n  }]) && i(n.prototype, r), o && i(n, o), a;\n}();\n\nfunction g() {\n  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n      r = e.timeout,\n      o = void 0 === r ? 12e5 : r,\n      i = e.element,\n      u = void 0 === i ? f : i,\n      l = e.events,\n      c = void 0 === l ? v : l,\n      a = e.onIdle,\n      s = void 0 === a ? function () {} : a,\n      m = e.onActive,\n      g = void 0 === m ? function () {} : m,\n      b = e.onAction,\n      T = void 0 === b ? function () {} : b,\n      y = e.debounce,\n      w = void 0 === y ? 0 : y,\n      I = e.throttle,\n      _ = void 0 === I ? 0 : I,\n      A = e.eventsThrottle,\n      E = void 0 === A ? 200 : A,\n      D = e.startOnMount,\n      O = void 0 === D || D,\n      S = e.stopOnIdle,\n      k = void 0 !== S && S,\n      M = e.capture,\n      L = void 0 === M || M,\n      R = e.passive,\n      j = void 0 === R || R,\n      P = t(!1),\n      X = t(!0),\n      Y = t(+new Date()),\n      B = t(null),\n      x = t(null),\n      U = t(null),\n      C = t(null),\n      W = t(null),\n      q = t(null),\n      z = t(0),\n      F = t(s),\n      G = t(g),\n      H = t(T),\n      J = function (e) {\n    var t = !X.current;\n    X.current = t, t ? (k && (clearTimeout(C.current), C.current = null, Q()), q.current = +new Date() - o, F.current(e)) : k || (z.current += +new Date() - q.current, N(), G.current(e));\n  },\n      K = function (e) {\n    if (H.current(e), !B.current) {\n      if (\"mousemove\" === e.type) {\n        if (e.pageX === x && e.pageY === U) return;\n        if (void 0 === e.pageX && void 0 === e.pageY) return;\n        if (Z() < 200) return;\n      }\n\n      clearTimeout(C.current), C.current = null;\n      var t = +new Date() - te();\n      (X.current && !k || !X.current && t > o) && J(e), W.current = +new Date(), x.current = e.pageX, U.current = e.pageY, X.current && k || (C.current = setTimeout(J, o));\n    }\n  },\n      N = function () {\n    d && (P.current || (c.forEach(function (e) {\n      u.addEventListener(e, K, {\n        capture: L,\n        passive: j\n      });\n    }), P.current = !0));\n  },\n      Q = function () {\n    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n    d && (P.current || e) && (c.forEach(function (e) {\n      u.removeEventListener(e, K, {\n        capture: L,\n        passive: j\n      });\n    }), P.current = !1);\n  },\n      V = function () {\n    if (null !== B.current) return B.current < 0 ? 0 : B.current;\n    var e = o - (+new Date() - W.current);\n    return e < 0 ? 0 : e;\n  },\n      Z = function () {\n    return +new Date() - Y.current;\n  },\n      $ = function () {\n    return q.current;\n  },\n      ee = function () {\n    return X.current ? +new Date() - q.current + z.current : z.current;\n  },\n      te = function () {\n    return W.current;\n  },\n      ne = function () {\n    return Z() - ee();\n  },\n      re = function () {\n    return X.current;\n  },\n      oe = function () {\n    clearTimeout(C.current), C.current = null, N(), X.current = !1, Y.current = +new Date(), W.current = +new Date(), B.current = null, C.current = setTimeout(J, o);\n  },\n      ie = function () {\n    null === B.current && (Q(), clearTimeout(C.current), C.current = null, B.current = V());\n  },\n      ue = function () {\n    null !== B.current && (N(), X.current || (C.current = setTimeout(J, B.current), B.current = null, W.current = +new Date()));\n  };\n\n  return n(function () {\n    if (w > 0 && _ > 0) throw new Error(\"onAction can either be throttled or debounced (not both)\");\n    return E > 0 && (K = h(K, E)), N(), O && oe(), function () {\n      clearTimeout(C.current), Q(!0);\n    };\n  }, []), n(function () {\n    F.current = s;\n  }, [s]), n(function () {\n    G.current = g;\n  }, [g]), n(function () {\n    H.current = w > 0 ? p(T, w) : _ > 0 ? h(T, _) : T;\n  }, [T]), {\n    isIdle: re,\n    pause: ie,\n    reset: oe,\n    resume: ue,\n    getLastIdleTime: $,\n    getTotalIdleTime: ee,\n    getLastActiveTime: te,\n    getTotalActiveTime: ne,\n    getElapsedTime: Z,\n    getRemainingTime: V\n  };\n}\n\nm.propTypes = {\n  timeout: r.number,\n  events: r.arrayOf(r.string),\n  onIdle: r.func,\n  onActive: r.func,\n  onAction: r.func,\n  debounce: r.number,\n  throttle: r.number,\n  eventsThrottle: r.number,\n  element: r.oneOfType([r.object, r.element]),\n  startOnMount: r.bool,\n  stopOnIdle: r.bool,\n  passive: r.bool,\n  capture: r.bool\n}, m.defaultProps = {\n  timeout: 12e5,\n  element: f,\n  events: v,\n  onIdle: function () {},\n  onActive: function () {},\n  onAction: function () {},\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: !0,\n  stopOnIdle: !1,\n  capture: !0,\n  passive: !0\n}, g.propTypes = {\n  timeout: r.number,\n  events: r.arrayOf(r.string),\n  onIdle: r.func,\n  onActive: r.func,\n  onAction: r.func,\n  debounce: r.number,\n  throttle: r.number,\n  eventsThrottle: r.number,\n  element: r.oneOfType([r.object, r.element]),\n  startOnMount: r.bool,\n  stopOnIdle: r.bool,\n  passive: r.bool,\n  capture: r.bool\n}, g.defaultProps = {\n  timeout: 12e5,\n  element: f,\n  events: v,\n  onIdle: function () {},\n  onActive: function () {},\n  onAction: function () {},\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: !0,\n  stopOnIdle: !1,\n  capture: !0,\n  passive: !0\n};\nexport default m;\nexport { g as useIdleTimer };","map":null,"metadata":{},"sourceType":"module"}
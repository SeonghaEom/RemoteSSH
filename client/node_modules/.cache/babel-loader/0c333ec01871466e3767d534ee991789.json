{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { PureComponent } from 'react';\nimport warning from 'warning';\nimport PropTypes from 'prop-types';\nimport Rail from '../Rail';\nimport Ticks from '../Ticks';\nimport Tracks from '../Tracks';\nimport Handles from '../Handles';\nimport { mode1, mode2, mode3 } from './modes';\nimport { isNotValidTouch, getTouchPosition, getUpdatedValues, getSliderDomain, getStepRange, getSortByVal } from './utils';\nimport LinearScale from './LinearScale';\nimport DiscreteScale from './DiscreteScale';\nvar prfx = 'react-compound-slider:';\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nvar noop = function noop() {};\n\nvar compare = function compare(b) {\n  return function (m, d, i) {\n    return m && b[i] === d;\n  };\n};\n\nvar equal = function equal(a, b) {\n  return a === b || a.length === b.length && a.reduce(compare(b), true);\n};\n\nvar getNextValue = function getNextValue(curr, step, domain, reversed) {\n  var newVal = curr;\n  newVal = reversed ? curr - step : curr + step;\n  return reversed ? Math.max(domain[0], newVal) : Math.min(domain[1], newVal);\n};\n\nvar getPrevValue = function getPrevValue(curr, step, domain, reversed) {\n  var newVal = curr;\n  newVal = reversed ? curr + step : curr - step;\n  return reversed ? Math.min(domain[1], newVal) : Math.max(domain[0], newVal);\n};\n\nvar Slider = function (_PureComponent) {\n  _inherits(Slider, _PureComponent);\n\n  function Slider(props) {\n    _classCallCheck(this, Slider);\n\n    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));\n\n    _this.state = {\n      values: []\n    };\n    _this.slider = null;\n    _this.valueToPerc = new LinearScale();\n    _this.valueToStep = new DiscreteScale();\n    _this.pixelToStep = new DiscreteScale();\n    _this.onMouseMove = _this.onMouseMove.bind(_this);\n    _this.onTouchMove = _this.onTouchMove.bind(_this);\n    _this.submitUpdate = _this.submitUpdate.bind(_this);\n    _this.onMouseDown = _this.onMouseDown.bind(_this);\n    _this.onTouchStart = _this.onTouchStart.bind(_this);\n    _this.onKeyDown = _this.onKeyDown.bind(_this);\n    _this.onStart = _this.onStart.bind(_this);\n    _this.onMouseUp = _this.onMouseUp.bind(_this);\n    _this.onTouchEnd = _this.onTouchEnd.bind(_this);\n    return _this;\n  }\n\n  Slider.prototype.componentWillMount = function componentWillMount() {\n    var _props = this.props,\n        values = _props.values,\n        domain = _props.domain,\n        step = _props.step,\n        reversed = _props.reversed;\n    this.updateRange(domain, step, reversed);\n    this.setValues(values, reversed);\n  };\n\n  Slider.prototype.componentWillReceiveProps = function componentWillReceiveProps(next) {\n    var domain = next.domain,\n        step = next.step,\n        reversed = next.reversed,\n        values = next.values;\n    var props = this.props;\n\n    if (domain[0] !== props.domain[0] || domain[1] !== props.domain[1] || step !== props.step || reversed !== props.reversed) {\n      this.updateRange(domain, step, reversed); // after adjusting the range based on the changed domain or step, make sure to update the values\n      // to fit with the new range\n\n      var remapped = this.reMapValues(reversed, values);\n\n      if (values === undefined || values === props.values) {\n        next.onChange(remapped);\n        next.onUpdate(remapped);\n      }\n    } else if (!equal(values, props.values)) {\n      // if domain didnt change, but the value props did, set the values\n      this.setValues(values, reversed);\n    }\n  };\n\n  Slider.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.removeListeners();\n  };\n\n  Slider.prototype.removeListeners = function removeListeners() {\n    if (isBrowser) {\n      document.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('mouseup', this.onMouseUp);\n      document.removeEventListener('touchmove', this.onTouchMove);\n      document.removeEventListener('touchend', this.onTouchEnd);\n    }\n  };\n\n  Slider.prototype.reMapValues = function reMapValues(reversed, values) {\n    // if values was not passed, fall back to using state\n    return this.setValues(values || this.state.values.map(function (d) {\n      return d.val;\n    }), reversed);\n  };\n\n  Slider.prototype.setValues = function setValues() {\n    var _this2 = this;\n\n    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var reversed = arguments[1];\n    var changes = 0;\n    var values = arr.map(function (x) {\n      var val = _this2.valueToStep.getValue(x);\n\n      if (x !== val) {\n        changes += 1;\n        warning(false, prfx + ' Invalid value encountered. Changing ' + x + ' to ' + val + '.');\n      }\n\n      return val;\n    }).map(function (val, i) {\n      return {\n        key: '$$-' + i,\n        val: val\n      };\n    }).sort(getSortByVal(reversed));\n    var valuesArr = values.map(function (d) {\n      return d.val;\n    });\n\n    if (changes > 0) {\n      this.props.onUpdate(valuesArr);\n      this.props.onChange(valuesArr);\n    }\n\n    this.setState(function () {\n      return {\n        values: values\n      };\n    });\n    return valuesArr;\n  };\n\n  Slider.prototype.updateRange = function updateRange(_ref, step, reversed) {\n    var min = _ref[0],\n        max = _ref[1];\n    var range = getStepRange(min, max, step);\n    this.valueToStep.setRange(range).setDomain([min - step / 2, max + step / 2]);\n\n    if (reversed === true) {\n      this.valueToPerc.setDomain([min, max]).setRange([100, 0]);\n      range.reverse();\n    } else {\n      this.valueToPerc.setDomain([min, max]).setRange([0, 100]);\n    }\n\n    this.pixelToStep.setRange(range);\n    warning(max > min, prfx + ' Max must be greater than min (even if reversed). Max is ' + max + '. Min is ' + min + '.');\n    var maxInRange = 100001;\n    warning(range.length <= maxInRange, prfx + ' Increase step value (set to ' + step + ' currently). Found ' + range.length.toLocaleString() + ' values in range. Max is ' + maxInRange.toLocaleString() + '.');\n    var last = range.length - 1;\n    warning(range[reversed ? last : 0] === min && range[reversed ? 0 : last] === max, prfx + ' The range is incorrectly calculated. Check domain (min, max) and step values.');\n  };\n\n  Slider.prototype.onKeyDown = function onKeyDown(e, handleID) {\n    var validUpKeys = ['ArrowRight', 'ArrowUp'];\n    var validDownKeys = ['ArrowDown', 'ArrowLeft'];\n    var values = this.state.values,\n        _props2 = this.props,\n        step = _props2.step,\n        reversed = _props2.reversed,\n        vertical = _props2.vertical,\n        domain = _props2.domain;\n    var key = e.key || e.keyCode;\n\n    if (!validUpKeys.concat(validDownKeys).includes(key)) {\n      return;\n    }\n\n    if (vertical) {\n      var _ref2 = [validDownKeys, validUpKeys];\n      validUpKeys = _ref2[0];\n      validDownKeys = _ref2[1];\n    }\n\n    e.stopPropagation && e.stopPropagation();\n    e.preventDefault && e.preventDefault();\n    var found = values.find(function (value) {\n      return value.key === handleID;\n    });\n\n    if (!found) {\n      return;\n    }\n\n    var currVal = found.val;\n    var newVal = currVal;\n\n    if (validUpKeys.includes(key)) {\n      newVal = getNextValue(currVal, step, domain, reversed);\n    } else if (validDownKeys.includes(key)) {\n      newVal = getPrevValue(currVal, step, domain, reversed);\n    }\n\n    var nextValues = values.map(function (v) {\n      return v.key === handleID ? {\n        key: v.key,\n        val: newVal\n      } : v;\n    });\n    this.submitUpdate(nextValues, true);\n  };\n\n  Slider.prototype.onMouseDown = function onMouseDown(e, handleID) {\n    this.onStart(e, handleID, false);\n  };\n\n  Slider.prototype.onTouchStart = function onTouchStart(e, handleID) {\n    if (isNotValidTouch(e)) {\n      return;\n    }\n\n    this.onStart(e, handleID, true);\n  };\n\n  Slider.prototype.onStart = function onStart(e, handleID, isTouch) {\n    var values = this.state.values,\n        onSlideStart = this.props.onSlideStart;\n    e.stopPropagation && e.stopPropagation();\n    e.preventDefault && e.preventDefault();\n    var found = values.find(function (value) {\n      return value.key === handleID;\n    });\n\n    if (found) {\n      this.active = handleID;\n      onSlideStart(values.map(function (d) {\n        return d.val;\n      }), {\n        activeHandleID: handleID\n      });\n      isTouch ? this.addTouchEvents() : this.addMouseEvents();\n    } else {\n      this.active = null;\n      this.handleRailAndTrackClicks(e, isTouch);\n    }\n  };\n\n  Slider.prototype.handleRailAndTrackClicks = function handleRailAndTrackClicks(e, isTouch) {\n    var curr = this.state.values,\n        _props3 = this.props,\n        vertical = _props3.vertical,\n        reversed = _props3.reversed;\n    var slider = this.slider; // double check the dimensions of the slider\n\n    this.pixelToStep.setDomain(getSliderDomain(slider, vertical, this.pixelToStep)); // find the closest value (aka step) to the event location\n\n    var updateValue = void 0;\n\n    if (isTouch) {\n      updateValue = this.pixelToStep.getValue(getTouchPosition(vertical, e));\n    } else {\n      updateValue = this.pixelToStep.getValue(vertical ? e.clientY : e.pageX);\n    } // find the closest handle key\n\n\n    var updateKey = null;\n    var minDiff = Infinity;\n\n    for (var i = 0; i < curr.length; i++) {\n      var _curr$i = curr[i],\n          key = _curr$i.key,\n          val = _curr$i.val;\n      var diff = Math.abs(val - updateValue);\n\n      if (diff < minDiff) {\n        updateKey = key;\n        minDiff = diff;\n      }\n    } // generate a \"candidate\" set of values - a suggestion of what to do\n\n\n    var nextValues = getUpdatedValues(curr, updateKey, updateValue, reversed); // submit the candidate values\n\n    this.submitUpdate(nextValues, true);\n  };\n\n  Slider.prototype.addMouseEvents = function addMouseEvents() {\n    if (isBrowser) {\n      document.addEventListener('mousemove', this.onMouseMove);\n      document.addEventListener('mouseup', this.onMouseUp);\n    }\n  };\n\n  Slider.prototype.addTouchEvents = function addTouchEvents() {\n    if (isBrowser) {\n      document.addEventListener('touchmove', this.onTouchMove);\n      document.addEventListener('touchend', this.onTouchEnd);\n    }\n  };\n\n  Slider.prototype.onMouseMove = function onMouseMove(e) {\n    var curr = this.state.values,\n        _props4 = this.props,\n        vertical = _props4.vertical,\n        reversed = _props4.reversed;\n    var updateKey = this.active,\n        slider = this.slider; // double check the dimensions of the slider\n\n    this.pixelToStep.setDomain(getSliderDomain(slider, vertical, this.pixelToStep)); // find the closest value (aka step) to the event location\n\n    var updateValue = this.pixelToStep.getValue(vertical ? e.clientY : e.pageX); // generate a \"candidate\" set of values - a suggestion of what to do\n\n    var nextValues = getUpdatedValues(curr, updateKey, updateValue, reversed); // submit the candidate values\n\n    this.submitUpdate(nextValues);\n  };\n\n  Slider.prototype.onTouchMove = function onTouchMove(e) {\n    var curr = this.state.values,\n        _props5 = this.props,\n        vertical = _props5.vertical,\n        reversed = _props5.reversed;\n    var updateKey = this.active,\n        slider = this.slider;\n\n    if (isNotValidTouch(e)) {\n      return;\n    } // double check the dimensions of the slider\n\n\n    this.pixelToStep.setDomain(getSliderDomain(slider, vertical, this.pixelToStep)); // find the closest value (aka step) to the event location\n\n    var updateValue = this.pixelToStep.getValue(getTouchPosition(vertical, e)); // generate a \"candidate\" set of values - a suggestion of what to do\n\n    var nextValues = getUpdatedValues(curr, updateKey, updateValue, reversed); // submit the candidate values\n\n    this.submitUpdate(nextValues);\n  };\n\n  Slider.prototype.submitUpdate = function submitUpdate(next, callOnChange) {\n    var _props6 = this.props,\n        mode = _props6.mode,\n        step = _props6.step,\n        onUpdate = _props6.onUpdate,\n        onChange = _props6.onChange,\n        reversed = _props6.reversed;\n    var getValue = this.valueToStep.getValue;\n    this.setState(function (_ref3) {\n      var curr = _ref3.values;\n      var values = void 0; // given the current values and a candidate set, decide what to do\n\n      if (typeof mode === 'function') {\n        values = mode(curr, next, step, reversed, getValue);\n        warning(Array.isArray(values), 'Custom mode function did not return an array.');\n      } else {\n        switch (mode) {\n          case 1:\n            values = mode1(curr, next);\n            break;\n\n          case 2:\n            values = mode2(curr, next);\n            break;\n\n          case 3:\n            values = mode3(curr, next, step, reversed, getValue);\n            break;\n\n          default:\n            values = next;\n            warning(false, prfx + ' Invalid mode value.');\n        }\n      }\n\n      onUpdate(values.map(function (d) {\n        return d.val;\n      }));\n\n      if (callOnChange) {\n        onChange(values.map(function (d) {\n          return d.val;\n        }));\n      }\n\n      return {\n        values: values\n      };\n    });\n  };\n\n  Slider.prototype.onMouseUp = function onMouseUp() {\n    var values = this.state.values,\n        _props7 = this.props,\n        onChange = _props7.onChange,\n        onSlideEnd = _props7.onSlideEnd;\n    var activeHandleID = this.active;\n    this.active = null;\n    onChange(values.map(function (d) {\n      return d.val;\n    }));\n    onSlideEnd(values.map(function (d) {\n      return d.val;\n    }), {\n      activeHandleID: activeHandleID\n    });\n\n    if (isBrowser) {\n      document.removeEventListener('mousemove', this.onMouseMove);\n      document.removeEventListener('mouseup', this.onMouseUp);\n    }\n  };\n\n  Slider.prototype.onTouchEnd = function onTouchEnd() {\n    var values = this.state.values,\n        _props8 = this.props,\n        onChange = _props8.onChange,\n        onSlideEnd = _props8.onSlideEnd;\n    this.active = null;\n    onChange(values.map(function (d) {\n      return d.val;\n    }));\n    onSlideEnd(values.map(function (d) {\n      return d.val;\n    }));\n\n    if (isBrowser) {\n      document.removeEventListener('touchmove', this.onTouchMove);\n      document.removeEventListener('touchend', this.onTouchEnd);\n    }\n  };\n\n  Slider.prototype.render = function render() {\n    var _this3 = this;\n\n    var values = this.state.values,\n        _props9 = this.props,\n        className = _props9.className,\n        rootStyle = _props9.rootStyle;\n    var handles = values.map(function (_ref4) {\n      var key = _ref4.key,\n          val = _ref4.val;\n      return {\n        id: key,\n        value: val,\n        percent: _this3.valueToPerc.getValue(val)\n      };\n    });\n    var children = React.Children.map(this.props.children, function (child) {\n      if (child.type.name === Rail.name || child.type.name === Ticks.name || child.type.name === Tracks.name || child.type.name === Handles.name) {\n        return React.cloneElement(child, {\n          scale: _this3.valueToPerc,\n          handles: handles,\n          emitKeyboard: _this3.onKeyDown,\n          emitMouse: _this3.onMouseDown,\n          emitTouch: _this3.onTouchStart\n        });\n      }\n\n      return child;\n    });\n    return React.createElement('div', {\n      style: rootStyle || {},\n      className: className,\n      ref: function ref(d) {\n        return _this3.slider = d;\n      }\n    }, children);\n  };\n\n  return Slider;\n}(PureComponent);\n\nSlider.propTypes = {\n  /**\n   * CSS class name applied to the root div of the slider.\n   */\n  className: PropTypes.string,\n\n  /**\n   * An object with any inline styles you want applied to the root div.\n   */\n  rootStyle: PropTypes.object,\n\n  /**\n   * Two element array of numbers providing the min and max values for the slider [min, max] e.g. [0, 100].\n   * It does not matter if the slider is reversed on the screen, domain is always [min, max] with min < max.\n   */\n  domain: PropTypes.array,\n\n  /**\n   * An array of numbers. You can supply one for a value slider, two for a range slider or more to create n-handled sliders.\n   * The values should correspond to valid step values in the domain.\n   * The numbers will be forced into the domain if they are two small or large.\n   */\n  values: PropTypes.array,\n\n  /**\n   * The step value for the slider.\n   */\n  step: PropTypes.number,\n\n  /**\n   * The interaction mode. Value of 1 will allow handles to cross each other.\n   * Value of 2 will keep the sliders from crossing and separated by a step.\n   * Value of 3 will make the handles pushable and keep them a step apart.\n   * ADVANCED: You can also supply a function that will be passed the current values and the incoming update.\n   * Your function should return what the state should be set as.\n   */\n  mode: PropTypes.oneOfType([PropTypes.number, PropTypes.func]),\n\n  /**\n   * Set to true if the slider is displayed vertically to tell the slider to use the height to calculate positions.\n   */\n  vertical: PropTypes.bool,\n\n  /**\n   * Reverse the display of slider values.\n   */\n  reversed: PropTypes.bool,\n\n  /**\n   * Function triggered when the value of the slider has changed. This will recieve changes at the end of a slide as well as changes from clicks on rails and tracks. Receives values.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * Function called with the values at each update (caution: high-volume updates when dragging). Receives values.\n   */\n  onUpdate: PropTypes.func,\n\n  /**\n   * Function triggered with ontouchstart or onmousedown on a handle. Receives values.\n   */\n  onSlideStart: PropTypes.func,\n\n  /**\n   * Function triggered on ontouchend or onmouseup on a handle. Receives values.\n   */\n  onSlideEnd: PropTypes.func,\n\n  /**\n   * Component children to render\n   */\n  children: PropTypes.any\n};\nSlider.defaultProps = {\n  mode: 1,\n  step: 0.1,\n  domain: [0, 100],\n  vertical: false,\n  reversed: false,\n  onChange: noop,\n  onUpdate: noop,\n  onSlideStart: noop,\n  onSlideEnd: noop\n};\nexport default Slider;","map":null,"metadata":{},"sourceType":"module"}